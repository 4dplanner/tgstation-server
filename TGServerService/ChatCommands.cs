using TGServiceInterface;
using System;
using System.Collections.Generic;
using System.Threading;

namespace TGServerService.ChatCommands
{
	/// <summary>
	/// Metadata about the currently running <see cref="ChatCommand"/>
	/// </summary>
	sealed class CommandInfo
	{
		/// <summary>
		/// If the <see cref="ChatCommand"/> was invoked by an admin
		/// </summary>
		public bool IsAdmin { get; set; }
		/// <summary>
		/// If the <see cref="ChatCommand"/> was invoked from an admin chat channel
		/// </summary>
		public bool IsAdminChannel { get; set; }
		/// <summary>
		/// The name of the <see cref="ChatCommand"/> invoker
		/// </summary>
		public string Speaker { get; set; }
		/// <summary>
		/// A reference to the <see cref="ServerInstance"/> that runs the <see cref="ChatProviders.ITGChatProvider"/> that heard the <see cref="ChatCommand"/>
		/// </summary>
		public ServerInstance Server { get; set; }
	}
	/// <summary>
	/// A command heard by a <see cref="ChatProviders.ITGChatProvider"/>
	/// </summary>
	abstract class ChatCommand : Command
	{
		/// <summary>
		/// <see cref="CommandInfo"/> for the <see cref="ChatCommand"/>
		/// </summary>
		public static ThreadLocal<CommandInfo> CommandInfo { get; private set; } = new ThreadLocal<CommandInfo>();
		/// <summary>
		/// If set to <see langword="true"/>, the <see cref="ChatCommand"/> cannot be invoked by a non-admin or outside an admin chat channel
		/// </summary>
		public bool RequiresAdmin { get; protected set; }
		/// <summary>
		/// Shorthand for accessing <see cref="CommandInfo.Server"/>
		/// </summary>
		protected ServerInstance Instance { get { return CommandInfo.Value.Server; } }

		/// <inheritdoc />
		public override ExitCode DoRun(IList<string> parameters)
		{
			if (RequiresAdmin)
			{
				var Info = CommandInfo.Value;
				if (!Info.IsAdmin)
				{
					OutputProc("You are not authorized to use that command!");
					return ExitCode.BadCommand;
				}
				if (!Info.IsAdminChannel)
				{
					OutputProc("Use this command in an admin channel!");
					return ExitCode.BadCommand;
				}
			}
			return base.DoRun(parameters);
		}
	}

	/// <summary>
	/// <see cref="ChatCommand"/>s generated by DreamDaemon via the API
	/// </summary>
	sealed class ServerChatCommand : ChatCommand
	{
		/// <summary>
		/// The help text for the <see cref="ServerChatCommand"/>
		/// </summary>
		readonly string HelpText;

		/// <summary>
		/// Construct a <see cref="ServerChatCommand"/>
		/// </summary>
		/// <param name="name">The invocation of the <see cref="ServerChatCommand"/></param>
		/// <param name="helpText">The help text of the <see cref="ServerChatCommand"/></param>
		/// <param name="adminOnly">If set to <see langword="true"/>, the <see cref="ServerChatCommand"/> cannot be invoked by a non-admin or outside an admin chat channel</param>
		/// <param name="requiredParameters">The number of parameters the <see cref="ServerChatCommand"/> requires</param>
		public ServerChatCommand(string name, string helpText, bool adminOnly, int requiredParameters)
		{
			Keyword = name;
			RequiresAdmin = adminOnly;
			HelpText = helpText;
			RequiredParameters = requiredParameters;
		}

		/// <inheritdoc />
		public override string GetHelpText()
		{
			return HelpText;
		}

		/// <inheritdoc />
		protected override ExitCode Run(IList<string> parameters)
		{
			var res = Instance.SendCommand(String.Format("{0};sender={1};custom={2}", Keyword, CommandInfo.Value.Speaker, Program.SanitizeTopicString(String.Join(" ", parameters))));
			if (res != "SUCCESS" && !String.IsNullOrWhiteSpace(res))
				OutputProc(res);
			return ExitCode.Normal;
		}
	}

	/// <summary>
	/// The main root chat command
	/// </summary>
	sealed class RootChatCommand : RootCommand
	{
		/// <summary>
		/// Construct a <see cref="RootChatCommand"/>
		/// </summary>
		/// <param name="serverCommands">List of <see cref="ServerChatCommand"/>s supplied by DreamDaemon</param>
		public RootChatCommand(List<Command> serverCommands)
		{
			var tmp = new List<Command> { new PRsCommand(), new VersionCommand(), new RevisionCommand(), new ByondCommand(), new KekCommand() };
			if (serverCommands != null)
				tmp.AddRange(serverCommands);
			Children = tmp.ToArray();
			serverCommands = new List<Command>();
			PrintHelpList = true;
		}
	}
	/// <summary>
	/// Retrieves the git SHA of the live DreamDaemon code
	/// </summary>
	sealed class RevisionCommand : ChatCommand
	{
		/// <summary>
		/// Construct a <see cref="RevisionCommand"/>
		/// </summary>
		public RevisionCommand()
		{
			Keyword = "revision";
		}
		/// <inheritdoc />
		protected override ExitCode Run(IList<string> parameters)
		{
			var res = Instance.LiveSha();
			if (res == "UNKNOWN") {
				OutputProc(res);
				return ExitCode.ServerError;
			}
			OutputProc(String.Format("^{0}", res));
			return ExitCode.Normal;
		}

		/// <inheritdoc />
		public override string GetHelpText()
		{
			return "Prints the current code revision of the repository (not the server)";
		}
	}
	/// <summary>
	/// Retrieve the installed, staged, or latest availab
	/// </summary>
	sealed class ByondCommand : ChatCommand
	{
		/// <summary>
		/// Construct a <see cref="ByondCommand"/>
		/// </summary>
		public ByondCommand()
		{
			Keyword = "byond";
		}

		/// <inheritdoc />
		protected override ExitCode Run(IList<string> parameters)
		{
			var type = ByondVersion.Installed;
			if (parameters.Count > 0)
				if (parameters[0].ToLower() == "--staged")
					type = ByondVersion.Staged;
				else if (parameters[0].ToLower() == "--latest")
					type = ByondVersion.Latest;
			OutputProc(Instance.GetVersion(type) ?? "None");
			return ExitCode.Normal;
		}

		/// <inheritdoc />
		public override string GetHelpText()
		{
			return "Gets the specified BYOND version";
		}

		/// <inheritdoc />
		public override string GetArgumentString()
		{
			return "[--staged|--latest]";
		}
	}
	/// <summary>
	/// Retrieve the current service version
	/// </summary>
	sealed class VersionCommand : ChatCommand
	{
		/// <summary>
		/// Construct a <see cref="VersionCommand"/>
		/// </summary>
		public VersionCommand()
		{
			Keyword = "version";
		}

		/// <inheritdoc />
		protected override ExitCode Run(IList<string> parameters)
		{
			OutputProc(Instance.Version());
			return ExitCode.Normal;
		}

		/// <inheritdoc />
		public override string GetHelpText()
		{
			return "Gets the running service version";
		}
	}
	/// <summary>
	/// kek
	/// </summary>
	sealed class KekCommand : ChatCommand
	{
		/// <summary>
		/// Construct a <see cref="KekCommand"/>
		/// </summary>
		public KekCommand()
		{
			Keyword = "kek";
		}

		/// <inheritdoc />
		protected override ExitCode Run(IList<string> parameters)
		{
			OutputProc("kek");
			return ExitCode.Normal;
		}

		/// <inheritdoc />
		public override string GetHelpText()
		{
			return "kek";
		}
	}
	/// <summary>
	/// Retrieve the list of test-merged github pull requests
	/// </summary>
	sealed class PRsCommand : ChatCommand
	{
		/// <summary>
		/// Construct a <see cref="PRsCommand"/>
		/// </summary>
		public PRsCommand()
		{
			Keyword = "prs";
		}

		/// <inheritdoc />
		protected override ExitCode Run(IList<string> parameters)
		{
			var PRs = Instance.MergedPullRequests(out string res);
			if (PRs == null)
			{
				OutputProc(res);
				return ExitCode.ServerError;
			}
			if (PRs.Count == 0)
				OutputProc("None!");
			else
			{
				res = "";
				foreach (var I in PRs)
					res += "#" + I.Number + " ";
				OutputProc(res);
			}
			return ExitCode.Normal;
		}

		/// <inheritdoc />
		public override string GetHelpText()
		{
			return "Gets the currently merged pull requests in the repository";
		}
	}
	
}
